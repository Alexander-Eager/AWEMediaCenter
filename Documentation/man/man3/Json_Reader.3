.TH "Json::Reader" 3 "Sat May 10 2014" "Version 0.1" "AWE Media Center" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Json::Reader \- 
.PP
Unserialize a \fCJSON\fP document into a \fBValue\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <json\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBErrorInfo\fP"
.br
.ti -1c
.RI "class \fBToken\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef char \fBChar\fP"
.br
.ti -1c
.RI "typedef const Char * \fBLocation\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBReader\fP ()"
.br
.RI "\fIConstructs a \fBReader\fP allowing all features for parsing\&. \fP"
.ti -1c
.RI "\fBReader\fP (const \fBFeatures\fP &features)"
.br
.RI "\fIConstructs a \fBReader\fP allowing the specified feature set for parsing\&. \fP"
.ti -1c
.RI "bool \fBparse\fP (const std::string &document, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "\fIRead a \fBValue\fP from a \fCJSON\fP document\&. \fP"
.ti -1c
.RI "bool \fBparse\fP (const char *beginDoc, const char *endDoc, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "\fIRead a \fBValue\fP from a \fCJSON\fP document\&. \fP"
.ti -1c
.RI "bool \fBparse\fP (std::istream &is, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "\fIParse from input stream\&. \fP"
.ti -1c
.RI "std::string \fBgetFormatedErrorMessages\fP () const "
.br
.RI "\fIReturns a user friendly string that list errors in the parsed document\&. \fP"
.ti -1c
.RI "std::string \fBgetFormattedErrorMessages\fP () const "
.br
.RI "\fIReturns a user friendly string that list errors in the parsed document\&. \fP"
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBTokenType\fP { \fBtokenEndOfStream\fP = 0, \fBtokenObjectBegin\fP, \fBtokenObjectEnd\fP, \fBtokenArrayBegin\fP, \fBtokenArrayEnd\fP, \fBtokenString\fP, \fBtokenNumber\fP, \fBtokenTrue\fP, \fBtokenFalse\fP, \fBtokenNull\fP, \fBtokenArraySeparator\fP, \fBtokenMemberSeparator\fP, \fBtokenComment\fP, \fBtokenError\fP }"
.br
.ti -1c
.RI "typedef std::deque< \fBErrorInfo\fP > \fBErrors\fP"
.br
.ti -1c
.RI "typedef std::stack< \fBValue\fP * > \fBNodes\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "bool \fBexpectToken\fP (TokenType type, \fBToken\fP &token, const char *message)"
.br
.ti -1c
.RI "bool \fBreadToken\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "void \fBskipSpaces\fP ()"
.br
.ti -1c
.RI "bool \fBmatch\fP (Location pattern, int patternLength)"
.br
.ti -1c
.RI "bool \fBreadComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadCStyleComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadCppStyleComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadString\fP ()"
.br
.ti -1c
.RI "void \fBreadNumber\fP ()"
.br
.ti -1c
.RI "bool \fBreadValue\fP ()"
.br
.ti -1c
.RI "bool \fBreadObject\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBreadArray\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeNumber\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeString\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeString\fP (\fBToken\fP &token, std::string &decoded)"
.br
.ti -1c
.RI "bool \fBdecodeDouble\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeUnicodeCodePoint\fP (\fBToken\fP &token, Location &current, Location end, unsigned int &unicode)"
.br
.ti -1c
.RI "bool \fBdecodeUnicodeEscapeSequence\fP (\fBToken\fP &token, Location &current, Location end, unsigned int &unicode)"
.br
.ti -1c
.RI "bool \fBaddError\fP (const std::string &message, \fBToken\fP &token, Location extra=0)"
.br
.ti -1c
.RI "bool \fBrecoverFromError\fP (TokenType skipUntilToken)"
.br
.ti -1c
.RI "bool \fBaddErrorAndRecover\fP (const std::string &message, \fBToken\fP &token, TokenType skipUntilToken)"
.br
.ti -1c
.RI "void \fBskipUntilSpace\fP ()"
.br
.ti -1c
.RI "\fBValue\fP & \fBcurrentValue\fP ()"
.br
.ti -1c
.RI "Char \fBgetNextChar\fP ()"
.br
.ti -1c
.RI "void \fBgetLocationLineAndColumn\fP (Location location, int &line, int &column) const "
.br
.ti -1c
.RI "std::string \fBgetLocationLineAndColumn\fP (Location location) const "
.br
.ti -1c
.RI "void \fBaddComment\fP (Location begin, Location end, \fBCommentPlacement\fP placement)"
.br
.ti -1c
.RI "void \fBskipCommentTokens\fP (\fBToken\fP &token)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Nodes \fBnodes_\fP"
.br
.ti -1c
.RI "Errors \fBerrors_\fP"
.br
.ti -1c
.RI "std::string \fBdocument_\fP"
.br
.ti -1c
.RI "Location \fBbegin_\fP"
.br
.ti -1c
.RI "Location \fBend_\fP"
.br
.ti -1c
.RI "Location \fBcurrent_\fP"
.br
.ti -1c
.RI "Location \fBlastValueEnd_\fP"
.br
.ti -1c
.RI "\fBValue\fP * \fBlastValue_\fP"
.br
.ti -1c
.RI "std::string \fBcommentsBefore_\fP"
.br
.ti -1c
.RI "\fBFeatures\fP \fBfeatures_\fP"
.br
.ti -1c
.RI "bool \fBcollectComments_\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Unserialize a \fCJSON\fP document into a \fBValue\fP\&. 


.SH "Member Function Documentation"
.PP 
.SS "std::string Json::Reader::getFormatedErrorMessages () const"

.PP
Returns a user friendly string that list errors in the parsed document\&. 
.PP
\fBReturns:\fP
.RS 4
Formatted error message with the list of errors with their location in the parsed document\&. An empty string is returned if no error occurred during parsing\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use \fBgetFormattedErrorMessages()\fP instead (typo fix)\&. 
.RE
.PP

.SS "std::string Json::Reader::getFormattedErrorMessages () const"

.PP
Returns a user friendly string that list errors in the parsed document\&. 
.PP
\fBReturns:\fP
.RS 4
Formatted error message with the list of errors with their location in the parsed document\&. An empty string is returned if no error occurred during parsing\&. 
.RE
.PP

.SS "bool Json::Reader::parse (const std::string &document, \fBValue\fP &root, boolcollectComments = \fCtrue\fP)"

.PP
Read a \fBValue\fP from a \fCJSON\fP document\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdocument\fP UTF-8 encoded string containing the document to read\&. 
.br
\fIroot\fP [out] Contains the root value of the document if it was successfully parsed\&. 
.br
\fIcollectComments\fP \fCtrue\fP to collect comment and allow writing them back during serialization, \fCfalse\fP to discard comments\&. This parameter is ignored if \fBFeatures::allowComments_\fP is \fCfalse\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the document was successfully parsed, \fCfalse\fP if an error occurred\&. 
.RE
.PP

.SS "bool Json::Reader::parse (const char *beginDoc, const char *endDoc, \fBValue\fP &root, boolcollectComments = \fCtrue\fP)"

.PP
Read a \fBValue\fP from a \fCJSON\fP document\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbeginDoc\fP Pointer on the beginning of the UTF-8 encoded string of the document to read\&. 
.br
\fIendDoc\fP Pointer on the end of the UTF-8 encoded string of the document to read\&. \\ Must be >= beginDoc\&. 
.br
\fIroot\fP [out] Contains the root value of the document if it was successfully parsed\&. 
.br
\fIcollectComments\fP \fCtrue\fP to collect comment and allow writing them back during serialization, \fCfalse\fP to discard comments\&. This parameter is ignored if \fBFeatures::allowComments_\fP is \fCfalse\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the document was successfully parsed, \fCfalse\fP if an error occurred\&. 
.RE
.PP

.SS "bool Json::Reader::parse (std::istream &is, \fBValue\fP &root, boolcollectComments = \fCtrue\fP)"

.PP
Parse from input stream\&. 
.PP
\fBSee Also:\fP
.RS 4
\fBJson::operator>>(std::istream&, Json::Value&)\fP\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for AWE Media Center from the source code\&.
